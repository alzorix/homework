'''эээ

№ 21598 (Уровень: Средний)
Система наблюдения ежеминутно фиксирует вход и выход сотрудников из офиса (в минутах, прошедших от начала суток). Считается, что в моменты фиксации входа и выхода сотрудник находится в офисе. Нулевая минута соответствует моменту начала рабочего дня в офисе, который длится 24 ч в сутки без перерыва.
Менеджер компании анализирует данные системы наблюдения за прошедшие сутки, и выявляет непересекающиеся отрезки времени наибольшей длины, в течение которых число сотрудников, находящихся в офисе, не изменялось.
Входной файл содержит время входа и выхода каждого сотрудника компании. Определите минуту, когда в предпоследний раз за сутки число сотрудников поменялось, и укажите наибольшую длину отрезка времени, когда количество сотрудников оставалось неизменным.

Входные данные
В первой строке входного файла находится натуральное
 число N (N ≤ 100 000) – количество сотрудников компании. Следующие N строк содержат пары чисел, обозначающих соответственно время входа и время выхода сотрудника (все числа натуральные, не превышающие 1440).
Запишите в ответе два натуральных числа: сначала минуту, когда в предпоследний раз за сутки число сотрудников поменялось, а затем
наибольшую длительность промежутка времени, при котором количество сотрудников оставалось неизменным'''

starts = list()
ends = list()
history = list()

with open("26_21598.txt") as file:
    line = int( file.readline().strip())
    line = file.readline().strip()
    while line !="":
        start,end = line.split()
        starts.append(int(start))
        ends.append(int(end))

        line = file.readline().strip()
situation = 0
combo = 0
combo_max = 0
ch = 0
for current_time in range(0,1441):
    situation -= ch#Считается, что в моменты фиксации входа и выхода сотрудник находится в офисе
    #поэтому мы создаем ch и изменяем данные с задежкой в тик
    last = situation

    ch = 0

    for t in starts:

        if current_time == t:
            situation+=1
    for t in ends:
        if current_time == t:
            ch+=1

    if last == situation:
        combo+=1
        combo_max = max(combo,combo_max)
    else:
        combo_max = max(combo, combo_max)
        combo =0

#Логика первого ответа:
starts = list(set(starts))
ends = list(set(ends))

starts.sort()
ends.sort()

print(max(starts[-2],ends[-2]),combo_max)
#1431 52
#54 неверно почему то