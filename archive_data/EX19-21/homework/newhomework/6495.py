'''(№ 6495) Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней, в каждой из них не менее одного камня.
 Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в большую кучу любое количество камней от одного до трёх
  или удвоить количество камней в меньшей куче. Если кучи содержат равное количество камней, можно добавить в любую из них от одного до трёх камней,
   удвоение в этой ситуации запрещено.
Игра завершается, когда количество камней в любой из двух куч становится больше или равно 65. Победителем считается игрок, сделавший последний ход,
то есть первым получивший 65 в одной куче.
Ответьте на следующие вопросы:
  Вопрос 1. Известно, что Петя смог выиграть первым ходом. Какое наименьшее число камней могло быть суммарно в двух кучах?
  Вопрос 2. Известно, что в первой куче 18 камней, а во второй – S камней (1 ≤ S ≤ 64). Найдите наименьшее и наибольшее значения S,
   при которых у Пети есть выигрышная стратегия, причём одновременно выполняются два условия:
– Петя не может выиграть за один ход;
– Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Запишите в ответе сначала наименьшее значение, потом – наибольшее.
  Вопрос 3. Известно, что в первой куче 26 камней, а во второй – S камней (1 ≤ S ≤ 64). Найдите значение S, при котором одновременно выполняются два условия:
— у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
— у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом. '''

print("19:")
#  Вопрос 1. Известно, что Петя смог выиграть первым ходом. Какое наименьшее число камней могло быть суммарно в двух кучах?
def F(A,B,H):
    #1 start
    #2 Pet
    #3 Van
    if H == 2 and (A >= 65 or B >= 65):
        return True
    if H == 2:
        return False
    if A >= 65 or B >= 65:
        return False
    A,B = sorted([A,B],reverse=True)

    moves = [F(A + 1, B, H + 1), F(A + 2, B, H + 1), F(A + 3, B, H + 1)]
        # Если удвоение возможно – добавляем и его; если нет, то не учитываем
    if A != B:
            moves.append(F(A, B * 2, H + 1))
    return any(moves)
F2 = list()
for S1 in range(1,200):
    for S2 in range(1,200):
        if F(S1,S2,1):
            F2.append(S1+S2)
print(min(F2))
#63
'''Вопрос 2. Известно, что в первой куче 18 камней, а во второй – S камней (1 ≤ S ≤ 64). Найдите наименьшее и наибольшее значения S,
   при которых у Пети есть выигрышная стратегия, причём одновременно выполняются два условия:
– Петя не может выиграть за один ход;
– Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
Запишите в ответе сначала наименьшее значение, потом – наибольшее.'''
print("20:")
#  Вопрос 1. Известно, что Петя смог выиграть первым ходом. Какое наименьшее число камней могло быть суммарно в двух кучах?
def F(A,B,H):
    #1 start
    #2 Pet
    #3 Van
    if H == 4 and (A >= 65 or B >= 65):
        return True
    if H == 4:
        return False
    if A >= 65 or B >= 65:
        return False
    A,B = sorted([A,B],reverse=True)
    if H % 2 == 0:
        moves = [F(A + 1, B, H + 1), F(A + 2, B, H + 1), F(A + 3, B, H + 1)]
        # Если удвоение возможно – добавляем и его; если нет, то не учитываем
        if A != B:
            moves.append(F(A, B * 2, H + 1))
        return all(moves)
    else:
        moves = [F(A + 1, B, H + 1), F(A + 2, B, H + 1), F(A + 3, B, H + 1)]
        # Если удвоение возможно – добавляем и его; если нет, то не учитываем
        if A != B:
            moves.append(F(A, B * 2, H + 1))
        return any(moves)


for S in range(1,65):
    if F(18, S, 1):
        print(S)
#36,60
print("21:")
''' Вопрос 3. Известно, что в первой куче 26 камней, а во второй – S камней (1 ≤ S ≤ 64). Найдите значение S, при котором одновременно выполняются два условия:
— у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
— у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.'''
def F_(A,B,H):
    #1 start
    #2 Pet
    #3 Van
    if H == 3 and (A >= 65 or B >= 65):
        return True
    if H == 3:
        return False
    if A >= 65 or B >= 65:
        return False
    A,B = sorted([A,B],reverse=True)
    if H % 2 == 0:
        moves = [F_(A + 1, B, H + 1), F_(A + 2, B, H + 1), F_(A + 3, B, H + 1)]
        # Если удвоение возможно – добавляем и его; если нет, то не учитываем
        if A != B:
            moves.append(F_(A, B * 2, H + 1))
        return any(moves)
    else:
        moves = [F_(A + 1, B, H + 1), F_(A + 2, B, H + 1), F_(A + 3, B, H + 1)]
        # Если удвоение возможно – добавляем и его; если нет, то не учитываем
        if A != B:
            moves.append(F_(A, B * 2, H + 1))
        return all(moves)

def F(A,B,H):
    #1 start
    #2 Pet
    #3 Van
    if (H == 3 or H == 5)and (A >= 65 or B >= 65):
        return True
    if H == 5:
        return False
    if A >= 65 or B >= 65:
        return False
    A,B = sorted([A,B],reverse=True)
    if H % 2 == 0:
        moves = [F(A + 1, B, H + 1), F(A + 2, B, H + 1), F(A + 3, B, H + 1)]
        # Если удвоение возможно – добавляем и его; если нет, то не учитываем
        if A != B:
            moves.append(F(A, B * 2, H + 1))
        return any(moves)
    else:
        moves = [F(A + 1, B, H + 1), F(A + 2, B, H + 1), F(A + 3, B, H + 1)]
        # Если удвоение возможно – добавляем и его; если нет, то не учитываем
        if A != B:
            moves.append(F(A, B * 2, H + 1))
        return all(moves)

for S in range(1,65):
    if not(F_(26, S, 1)) and F(26, S, 1):
        print(S)
        #57